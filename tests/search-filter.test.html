<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search and Filter Tests</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 0.5rem;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-case {
            margin: 1rem 0;
            padding: 1rem;
            border-left: 3px solid #ddd;
        }
        .test-case.pass {
            border-color: #4caf50;
            background: #f1f8f4;
        }
        .test-case.fail {
            border-color: #f44336;
            background: #fef1f0;
        }
        .test-result {
            font-weight: bold;
            margin-top: 0.5rem;
        }
        .pass .test-result { color: #4caf50; }
        .fail .test-result { color: #f44336; }
        .test-controls {
            margin: 1rem 0;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 0.5rem;
        }
        button:hover {
            background: #005a9e;
        }
        .summary {
            font-size: 1.2rem;
            font-weight: bold;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 2rem;
        }
        .summary.all-pass {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .summary.has-fail {
            background: #ffebee;
            color: #c62828;
        }
        pre {
            background: #f5f5f5;
            padding: 0.5rem;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>🧪 Search and Filter Tests - Enhanced Test Suite</h1>
    
    <div class="test-controls">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="runPerformanceTests()">Run Performance Tests</button>
        <button onclick="runFilterTests()">Run Filter Tests</button>
        <button onclick="runCrossBrowserTests()">Run Cross-Browser Tests</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div id="test-results"></div>
    <div id="summary"></div>

    <!-- Load performance optimizer and browser compatibility -->
    <script src="../site/js/browser-compatibility.js"></script>
    <script src="../site/js/performance-optimizer.js"></script>
    <script src="../site/js/data-normalizer.js"></script>
    <script src="../site/js/search-manager.js"></script>
    
    <script>
        // Comment 11: Enhanced test suite for search, filter, and performance
        let performanceOptimizer = null;
        let browserCompat = null;
        
        // Initialize performance modules
        if (window.PerformanceOptimizer) {
            performanceOptimizer = {
                filterManager: new window.PerformanceOptimizer.DebouncedFilterManager(),
                filterIndex: new window.PerformanceOptimizer.FilterIndex(),
                virtualRenderer: new window.PerformanceOptimizer.VirtualRenderer(),
                performanceMonitor: new window.PerformanceOptimizer.PerformanceMonitor(),
                memoryManager: new window.PerformanceOptimizer.MemoryManager()
            };
        }
        
        if (window.BrowserCompatibility) {
            browserCompat = window.BrowserCompatibility;
        }
        
        const testCases = [
            {
                name: 'SearchManager Initialization',
                category: 'Search',
                test: async () => {
                    // Load SearchManager if not already loaded
                    if (!window.SearchManager) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = '../site/js/search-manager.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    }
                    
                    const searchManager = new window.SearchManager();
                    const mockTools = [
                        { id: 0, name: 'test1', description: 'Test tool 1' },
                        { id: 1, name: 'test2', description: 'Test tool 2' }
                    ];
                    
                    await searchManager.initialize(mockTools);
                    
                    if (!searchManager.isReady) {
                        throw new Error('SearchManager not ready after initialization');
                    }
                    
                    const results = searchManager.search('test', { limit: 10 });
                    if (!Array.isArray(results)) {
                        throw new Error('Search did not return an array');
                    }
                    
                    return 'SearchManager initialized and working';
                }
            },
            {
                name: 'Debounce Function',
                category: 'Utilities',
                test: async () => {
                    let callCount = 0;
                    const debounced = ((func, delay) => {
                        let timeoutId;
                        return function(...args) {
                            clearTimeout(timeoutId);
                            return new Promise(resolve => {
                                timeoutId = setTimeout(() => {
                                    resolve(func.apply(this, args));
                                }, delay);
                            });
                        };
                    })(() => callCount++, 100);
                    
                    // Call multiple times quickly
                    debounced();
                    debounced();
                    debounced();
                    await debounced();
                    
                    // Should only execute once
                    if (callCount === 1) {
                        return 'Debounce working correctly';
                    } else {
                        throw `Expected 1 call, got ${callCount}`;
                    }
                }
            },
            {
                name: 'LRU Cache Implementation',
                category: 'Cache',
                test: async () => {
                    // Simplified LRU cache for testing
                    class LRUCache {
                        constructor(maxSize = 2) {
                            this.maxSize = maxSize;
                            this.cache = new Map();
                        }
                        get(key) {
                            if (!this.cache.has(key)) return undefined;
                            const value = this.cache.get(key);
                            this.cache.delete(key);
                            this.cache.set(key, value);
                            return value;
                        }
                        set(key, value) {
                            if (this.cache.has(key)) {
                                this.cache.delete(key);
                            } else if (this.cache.size >= this.maxSize) {
                                const firstKey = this.cache.keys().next().value;
                                this.cache.delete(firstKey);
                            }
                            this.cache.set(key, value);
                        }
                    }
                    
                    const cache = new LRUCache(2);
                    cache.set('a', 1);
                    cache.set('b', 2);
                    cache.set('c', 3); // Should evict 'a'
                    
                    if (cache.get('a') === undefined && cache.get('b') === 2 && cache.get('c') === 3) {
                        return 'LRU cache eviction working correctly';
                    } else {
                        throw 'LRU cache not working as expected';
                    }
                }
            },
            {
                name: 'Platform Filter Validation',
                category: 'Filters',
                test: async () => {
                    const validPlatforms = ['macOS', 'Linux', 'Windows', 'cross-platform', 'web'];
                    const testValues = [
                        { value: 'macOS', expected: true },
                        { value: 'linux', expected: true }, // Case insensitive
                        { value: 'WINDOWS', expected: true },
                        { value: 'invalid', expected: false },
                        { value: '', expected: false }
                    ];
                    
                    const validatePlatform = (value) => {
                        return validPlatforms.some(p => p.toLowerCase() === value.toLowerCase());
                    };
                    
                    for (const test of testValues) {
                        const result = validatePlatform(test.value);
                        if (result !== test.expected) {
                            throw `Platform validation failed for "${test.value}": expected ${test.expected}, got ${result}`;
                        }
                    }
                    
                    return 'Platform validation working correctly';
                }
            },
            {
                name: 'Installation Filter Normalization',
                category: 'Filters',
                test: async () => {
                    const normalizeInstallation = (value) => {
                        if (!value) return 'unknown';
                        const normalized = value.toLowerCase().trim();
                        
                        const mappings = {
                            'built-in': ['builtin', 'built in', 'native', 'system', 'default', 'included'],
                            'homebrew': ['brew', 'home-brew', 'home brew'],
                            'npm': ['node', 'npm', 'npx', 'nodejs', 'node.js'],
                            'pip': ['pip', 'pip3', 'python', 'pypi', 'python-pip']
                        };
                        
                        for (const [canonical, synonyms] of Object.entries(mappings)) {
                            if (synonyms.includes(normalized) || normalized === canonical) {
                                return canonical;
                            }
                        }
                        
                        return normalized;
                    };
                    
                    const tests = [
                        { input: 'brew', expected: 'homebrew' },
                        { input: 'native', expected: 'built-in' },
                        { input: 'npm', expected: 'npm' },
                        { input: 'python', expected: 'pip' },
                        { input: '', expected: 'unknown' }
                    ];
                    
                    for (const test of tests) {
                        const result = normalizeInstallation(test.input);
                        if (result !== test.expected) {
                            throw `Installation normalization failed for "${test.input}": expected "${test.expected}", got "${result}"`;
                        }
                    }
                    
                    return 'Installation normalization working correctly';
                }
            },
            {
                name: 'Query Preprocessing for Exact Match',
                category: 'Search',
                test: async () => {
                    const preprocessQuery = (query) => {
                        const isExactMatch = query.startsWith('"') && query.endsWith('"');
                        
                        if (isExactMatch) {
                            return query
                                .slice(1, -1)
                                .replace(/[^\w\s\-\_]/g, '')
                                .trim();
                        } else {
                            return query
                                .replace(/[\.]/g, ' ')
                                .replace(/[^\w\s\*\+\-\~\^\-\_]/g, '')
                                .trim();
                        }
                    };
                    
                    const tests = [
                        { input: '"exact-match"', expected: 'exact-match' },
                        { input: 'fuzzy.search', expected: 'fuzzy search' },
                        { input: 'test_query', expected: 'test_query' },
                        { input: '"test@#$query"', expected: 'testquery' }
                    ];
                    
                    for (const test of tests) {
                        const result = preprocessQuery(test.input);
                        if (result !== test.expected) {
                            throw `Query preprocessing failed for "${test.input}": expected "${test.expected}", got "${result}"`;
                        }
                    }
                    
                    return 'Query preprocessing working correctly';
                }
            },
            {
                name: 'Virtual Scrolling Threshold',
                category: 'Performance',
                test: async () => {
                    const shouldUseVirtualScrolling = (itemCount) => itemCount > 100;
                    
                    const tests = [
                        { count: 50, expected: false },
                        { count: 100, expected: false },
                        { count: 101, expected: true },
                        { count: 500, expected: true }
                    ];
                    
                    for (const test of tests) {
                        const result = shouldUseVirtualScrolling(test.count);
                        if (result !== test.expected) {
                            throw `Virtual scrolling threshold failed for ${test.count}: expected ${test.expected}, got ${result}`;
                        }
                    }
                    
                    return 'Virtual scrolling threshold working correctly';
                }
            },
            {
                name: 'HTML Escaping',
                category: 'Security',
                test: async () => {
                    const escapeHtml = (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    const tests = [
                        { input: '<script>alert("xss")</script>', expected: '&lt;script&gt;alert("xss")&lt;/script&gt;' },
                        { input: 'normal text', expected: 'normal text' },
                        { input: '"quotes" & \'apostrophes\'', expected: '"quotes" &amp; \'apostrophes\'' }
                    ];
                    
                    for (const test of tests) {
                        const result = escapeHtml(test.input);
                        if (result !== test.expected) {
                            throw `HTML escaping failed for "${test.input}": expected "${test.expected}", got "${result}"`;
                        }
                    }
                    
                    return 'HTML escaping working correctly';
                }
            },
            {
                name: 'DataNormalizer Platform Normalization',
                category: 'Data Normalization',
                test: async () => {
                    // Load DataNormalizer dynamically
                    if (!window.DataNormalizer) {
                        const script = document.createElement('script');
                        script.src = '../site/js/data-normalizer.js';
                        document.head.appendChild(script);
                        await new Promise(resolve => script.onload = resolve);
                    }
                    
                    const tests = [
                        { input: 'mac', expected: 'macOS' },
                        { input: 'osx', expected: 'macOS' },
                        { input: 'linux', expected: 'Linux' },
                        { input: 'ubuntu', expected: 'Linux' },
                        { input: 'win', expected: 'Windows' },
                        { input: 'win32', expected: 'Windows' },
                        { input: 'cross-platform', expected: 'cross-platform' }
                    ];
                    
                    for (const test of tests) {
                        const result = window.DataNormalizer.normalizePlatformString(test.input);
                        if (result !== test.expected) {
                            throw `Platform normalization failed for "${test.input}": expected "${test.expected}", got "${result}"`;
                        }
                    }
                    
                    return 'Platform normalization working correctly';
                }
            },
            {
                name: 'DataNormalizer Installation Normalization',
                category: 'Data Normalization',
                test: async () => {
                    if (!window.DataNormalizer) {
                        const script = document.createElement('script');
                        script.src = '../site/js/data-normalizer.js';
                        document.head.appendChild(script);
                        await new Promise(resolve => script.onload = resolve);
                    }
                    
                    const tests = [
                        { input: 'brew', expected: 'homebrew' },
                        { input: 'built in', expected: 'built-in' },
                        { input: 'npm', expected: 'npm' },
                        { input: 'node', expected: 'npm' },
                        { input: 'pip3', expected: 'pip' },
                        { input: 'apt', expected: 'package-manager' },
                        { input: 'compile', expected: 'source' }
                    ];
                    
                    for (const test of tests) {
                        const result = window.DataNormalizer.normalizeInstallationString(test.input);
                        if (result !== test.expected) {
                            throw `Installation normalization failed for "${test.input}": expected "${test.expected}", got "${result}"`;
                        }
                    }
                    
                    return 'Installation normalization working correctly';
                }
            },
            {
                name: 'DataLoader Integration',
                category: 'Data Loading',
                test: async () => {
                    // Load DataLoader dynamically
                    if (!window.DataLoader) {
                        const script = document.createElement('script');
                        script.src = '../site/js/data-loader.js';
                        document.head.appendChild(script);
                        await new Promise(resolve => script.onload = resolve);
                    }
                    
                    const loader = new window.DataLoader({
                        validateDuringLoad: false,
                        useCache: false,
                        dataPath: '../site/data/'
                    });
                    
                    // Test status tracking
                    let statusUpdates = [];
                    loader.on('status-update', (data) => {
                        statusUpdates.push(data);
                    });
                    
                    // Test mock data generation
                    const mockData = loader.generateMockData();
                    if (!mockData.tools || !mockData.categories || !mockData.stats) {
                        throw 'Mock data generation failed';
                    }
                    
                    if (!mockData.isMockData) {
                        throw 'Mock data should be marked as mock';
                    }
                    
                    return 'DataLoader integration working correctly';
                }
            },
            {
                name: 'DataValidator Enhanced Validation',
                category: 'Data Validation',
                test: async () => {
                    // Load DataValidator dynamically
                    if (!window.DataValidator) {
                        const script = document.createElement('script');
                        script.src = '../site/js/data-validator.js';
                        document.head.appendChild(script);
                        await new Promise(resolve => script.onload = resolve);
                    }
                    
                    const validator = new window.DataValidator();
                    
                    // Test with sample data
                    const testData = {
                        tools: [
                            { name: 'test1', description: 'Test tool 1', category: 'Test', platforms: ['macOS'] },
                            { name: 'test2', description: 'Test tool 2', category: 'Test', installation: 'npm' }
                        ],
                        categories: [
                            { name: 'Test', id: 'test', toolCount: 2 }
                        ],
                        stats: {
                            totalTools: 2,
                            totalCategories: 1,
                            lastUpdated: new Date().toISOString()
                        }
                    };
                    
                    const results = validator.validateDuringLoad(testData);
                    
                    if (!results) {
                        throw 'Validation should return results';
                    }
                    
                    if (results.tools.count !== 2) {
                        throw `Expected 2 tools, got ${results.tools.count}`;
                    }
                    
                    if (results.categories.count !== 1) {
                        throw `Expected 1 category, got ${results.categories.count}`;
                    }
                    
                    const recommendations = validator.generateRecommendations();
                    if (!Array.isArray(recommendations)) {
                        throw 'Recommendations should be an array';
                    }
                    
                    return 'Enhanced validation working correctly';
                }
            },
            // Performance Optimization Tests
            {
                name: 'FilterIndex Performance with Large Dataset',
                category: 'Performance',
                test: async () => {
                    if (!performanceOptimizer) {
                        return 'Performance optimizer not available - skipping';
                    }
                    
                    // Generate large dataset
                    const tools = [];
                    const categories = ['dev', 'network', 'system', 'text', 'media'];
                    const platforms = ['macOS', 'Linux', 'Windows'];
                    const installations = ['homebrew', 'npm', 'pip', 'built-in'];
                    
                    for (let i = 0; i < 500; i++) {
                        tools.push({
                            id: `tool-${i}`,
                            name: `Tool ${i}`,
                            category: categories[i % categories.length],
                            platform: [platforms[i % platforms.length]],
                            installation: [installations[i % installations.length]],
                            difficulty: (i % 5) + 1,
                            description: `Description for tool ${i}`
                        });
                    }
                    
                    // Build indexes
                    const startTime = performance.now();
                    performanceOptimizer.filterIndex.buildIndexes(tools);
                    const buildTime = performance.now() - startTime;
                    
                    // Test filter performance
                    const filterStartTime = performance.now();
                    const categoryResults = performanceOptimizer.filterIndex.getByCategory('dev');
                    const platformResults = performanceOptimizer.filterIndex.getByPlatform('macOS');
                    const filterTime = performance.now() - filterStartTime;
                    
                    if (buildTime > 50) {
                        throw `Index building too slow: ${buildTime.toFixed(2)}ms (should be < 50ms)`;
                    }
                    if (filterTime > 5) {
                        throw `Filtering too slow: ${filterTime.toFixed(2)}ms (should be < 5ms)`;
                    }
                    
                    return `FilterIndex performance good - Build: ${buildTime.toFixed(2)}ms, Filter: ${filterTime.toFixed(2)}ms`;
                }
            },
            {
                name: 'DebouncedFilterManager Operation Queuing',
                category: 'Performance',
                test: async () => {
                    if (!performanceOptimizer) {
                        return 'Performance optimizer not available - skipping';
                    }
                    
                    let callCount = 0;
                    const operation = () => callCount++;
                    
                    // Queue multiple operations quickly
                    performanceOptimizer.filterManager.queue('test-op', operation, 'filter');
                    performanceOptimizer.filterManager.queue('test-op', operation, 'filter');
                    performanceOptimizer.filterManager.queue('test-op', operation, 'filter');
                    
                    // Wait for debounce
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    if (callCount !== 1) {
                        throw `Expected 1 call after debouncing, got ${callCount}`;
                    }
                    
                    return 'DebouncedFilterManager working correctly';
                }
            },
            {
                name: 'VirtualRenderer Batch Rendering',
                category: 'Performance',
                test: async () => {
                    if (!performanceOptimizer) {
                        return 'Performance optimizer not available - skipping';
                    }
                    
                    const container = document.createElement('div');
                    const items = Array.from({ length: 100 }, (_, i) => ({ id: i, name: `Item ${i}` }));
                    
                    const startTime = performance.now();
                    
                    performanceOptimizer.virtualRenderer.queueRender(
                        items,
                        container,
                        (element, item) => {
                            element.textContent = item.name;
                        }
                    );
                    
                    // Wait for rendering to complete
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const renderTime = performance.now() - startTime;
                    
                    if (container.children.length !== 100) {
                        throw `Expected 100 rendered items, got ${container.children.length}`;
                    }
                    
                    if (renderTime > 1000) {
                        throw `Rendering too slow: ${renderTime.toFixed(2)}ms (should be < 1000ms)`;
                    }
                    
                    return `VirtualRenderer rendered 100 items in ${renderTime.toFixed(2)}ms`;
                }
            },
            // Cross-Browser Compatibility Tests
            {
                name: 'Browser Feature Detection',
                category: 'Cross-Browser',
                test: async () => {
                    if (!browserCompat) {
                        return 'Browser compatibility module not available - skipping';
                    }
                    
                    const criticalFeatures = [
                        'promise',
                        'fetch',
                        'querySelector',
                        'addEventListener',
                        'array.includes',
                        'object.assign'
                    ];
                    
                    const unsupported = [];
                    for (const feature of criticalFeatures) {
                        if (!browserCompat.isSupported(feature)) {
                            unsupported.push(feature);
                        }
                    }
                    
                    if (unsupported.length > 0) {
                        return `Missing critical features: ${unsupported.join(', ')} (polyfills may be loaded)`;
                    }
                    
                    return 'All critical browser features supported';
                }
            },
            // Filter Combination Tests
            {
                name: 'Combined Filter Application',
                category: 'Filters',
                test: async () => {
                    const tools = [
                        { id: 1, name: 'Tool 1', category: 'dev', platform: ['macOS'], difficulty: 3 },
                        { id: 2, name: 'Tool 2', category: 'dev', platform: ['Linux'], difficulty: 3 },
                        { id: 3, name: 'Tool 3', category: 'network', platform: ['macOS'], difficulty: 3 },
                        { id: 4, name: 'Tool 4', category: 'dev', platform: ['macOS'], difficulty: 4 }
                    ];
                    
                    // Filter: category=dev AND platform=macOS AND difficulty=3
                    const filtered = tools.filter(tool => 
                        tool.category === 'dev' &&
                        tool.platform.includes('macOS') &&
                        tool.difficulty === 3
                    );
                    
                    if (filtered.length !== 1 || filtered[0].id !== 1) {
                        throw `Combined filtering failed: expected tool 1, got ${JSON.stringify(filtered)}`;
                    }
                    
                    return 'Combined filter application working correctly';
                }
            },
            // Edge Case Tests
            {
                name: 'Empty Dataset Handling',
                category: 'Edge Cases',
                test: async () => {
                    const emptyTools = [];
                    
                    // Test with performance optimizer if available
                    if (performanceOptimizer) {
                        performanceOptimizer.filterIndex.buildIndexes(emptyTools);
                        const results = performanceOptimizer.filterIndex.getByCategory('dev');
                        if (results.size !== 0) {
                            throw `Expected empty Set, got ${results.size} items`;
                        }
                    }
                    
                    // Test search with empty dataset
                    if (window.SearchManager) {
                        const searchManager = new window.SearchManager();
                        await searchManager.initialize(emptyTools);
                        const searchResults = searchManager.search('test');
                        if (searchResults.length !== 0) {
                            throw `Expected empty search results, got ${searchResults.length} items`;
                        }
                    }
                    
                    return 'Empty dataset handling working correctly';
                }
            },
            // Performance Benchmark Tests
            {
                name: 'Filter 300+ Tools Performance',
                category: 'Performance Benchmarks',
                test: async () => {
                    const tools = Array.from({ length: 300 }, (_, i) => ({
                        id: `tool-${i}`,
                        name: `Tool ${i}`,
                        category: ['dev', 'network', 'system'][i % 3],
                        platform: [['macOS'], ['Linux'], ['Windows']][i % 3],
                        difficulty: (i % 5) + 1,
                        description: `Description for tool ${i}`
                    }));
                    
                    const startTime = performance.now();
                    
                    // Simulate filtering
                    const filtered = tools.filter(tool => 
                        tool.category === 'dev' &&
                        tool.platform[0] === 'macOS' &&
                        tool.difficulty >= 3
                    );
                    
                    const filterTime = performance.now() - startTime;
                    
                    if (filterTime > 10) {
                        throw `Filtering 300 tools took ${filterTime.toFixed(2)}ms (should be < 10ms)`;
                    }
                    
                    return `Filtered 300 tools in ${filterTime.toFixed(2)}ms`;
                }
            },
            {
                name: 'FilterIndex Synonym Normalization',
                category: 'Filters',
                test: async () => {
                    // Mock DataNormalizer if not already present
                    if (!window.DataNormalizer) {
                        window.DataNormalizer = {
                            normalizePlatformString: (platform) => {
                                const synonyms = {
                                    'osx': 'macOS',
                                    'mac os': 'macOS',
                                    'darwin': 'macOS'
                                };
                                return synonyms[platform.toLowerCase()] || platform;
                            },
                            normalizeInstallationString: (method) => {
                                const synonyms = {
                                    'brew': 'homebrew',
                                    'home-brew': 'homebrew',
                                    'python': 'pip',
                                    'pip3': 'pip',
                                    'node': 'npm',
                                    'npx': 'npm'
                                };
                                return synonyms[method.toLowerCase()] || method;
                            }
                        };
                    }
                    
                    // Test data with synonyms
                    const tools = [
                        { id: 1, name: 'Tool 1', platform: ['osx'], installation: ['brew'] },
                        { id: 2, name: 'Tool 2', platform: ['mac os'], installation: ['home-brew'] },
                        { id: 3, name: 'Tool 3', platform: ['macOS'], installation: ['homebrew'] },
                        { id: 4, name: 'Tool 4', platform: ['darwin'], installation: ['python'] },
                        { id: 5, name: 'Tool 5', platform: ['Linux'], installation: ['pip3'] }
                    ];
                    
                    // Test with performance optimizer FilterIndex
                    if (window.PerformanceOptimizer && window.PerformanceOptimizer.FilterIndex) {
                        const filterIndex = new window.PerformanceOptimizer.FilterIndex();
                        filterIndex.buildIndexes(tools);
                        
                        // Test platform normalization - all osx variants should map to macOS
                        const macosTools = filterIndex.getByPlatform('macOS');
                        if (macosTools.size !== 4) {
                            throw `Platform normalization failed: expected 4 macOS tools, got ${macosTools.size}`;
                        }
                        
                        // Test installation normalization - all brew variants should map to homebrew
                        const brewTools = filterIndex.getByInstallation('homebrew');
                        if (brewTools.size !== 3) {
                            throw `Installation normalization failed: expected 3 homebrew tools, got ${brewTools.size}`;
                        }
                        
                        // Test pip normalization
                        const pipTools = filterIndex.getByInstallation('pip');
                        if (pipTools.size !== 2) {
                            throw `Pip normalization failed: expected 2 pip tools, got ${pipTools.size}`;
                        }
                    }
                    
                    return 'FilterIndex synonym normalization working correctly';
                }
            }
        ];

        let testResults = [];

        async function runTest(testCase) {
            const startTime = performance.now();
            try {
                const result = await testCase.test();
                const duration = performance.now() - startTime;
                return {
                    name: testCase.name,
                    category: testCase.category,
                    passed: true,
                    message: result,
                    duration: duration.toFixed(2)
                };
            } catch (error) {
                const duration = performance.now() - startTime;
                return {
                    name: testCase.name,
                    category: testCase.category,
                    passed: false,
                    message: error.toString(),
                    duration: duration.toFixed(2)
                };
            }
        }

        async function runAllTests() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>Running tests...</h2>';
            
            testResults = [];
            
            for (const testCase of testCases) {
                const result = await runTest(testCase);
                testResults.push(result);
            }
            
            displayResults();
        }

        function displayResults(title = 'All Tests') {
            const resultsDiv = document.getElementById('test-results');
            const summaryDiv = document.getElementById('summary');
            
            // Add title
            resultsDiv.innerHTML = `<h2>${title} Results</h2>`;
            
            // Group results by category
            const categories = {};
            testResults.forEach(result => {
                if (!categories[result.category]) {
                    categories[result.category] = [];
                }
                categories[result.category].push(result);
            });
            
            // Display results by category
            let html = '';
            for (const [category, results] of Object.entries(categories)) {
                html += `<div class="test-section">`;
                html += `<h3>${category}</h3>`;
                
                results.forEach(result => {
                    html += `
                        <div class="test-case ${result.passed ? 'pass' : 'fail'}">
                            <strong>${result.name}</strong>
                            <div>${result.message}</div>
                            <div class="test-result">
                                ${result.passed ? '✅ PASS' : '❌ FAIL'} (${result.duration}ms)
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            resultsDiv.innerHTML = html;
            
            // Display summary
            const passed = testResults.filter(r => r.passed).length;
            const failed = testResults.filter(r => !r.passed).length;
            const total = testResults.length;
            
            summaryDiv.innerHTML = `
                <div class="summary ${failed === 0 ? 'all-pass' : 'has-fail'}">
                    Test Results: ${passed}/${total} passed, ${failed} failed
                </div>
            `;
        }

        function clearResults() {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('summary').innerHTML = '';
            testResults = [];
        }

        // Auto-run tests on load
        window.addEventListener('load', () => {
            console.log('Test suite loaded. Click "Run All Tests" to begin.');
        });
    </script>
</body>
</html>